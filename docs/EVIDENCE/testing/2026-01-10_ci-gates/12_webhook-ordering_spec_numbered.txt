     1	// Mock @neuronx/config before any imports
     2	jest.mock('@neuronx/config', () => ({
     3	  config: {
     4	    GHL_WEBHOOK_SECRET: 'test-webhook-secret',
     5	    SKIP_WEBHOOK_VERIFICATION: false,
     6	  },
     7	}));
     8	
     9	// Mock rate limit service before any imports
    10	jest.mock('../rate-limit.service', () => ({
    11	  RateLimitService: jest.fn().mockImplementation(() => ({
    12	    enforceWebhookRateLimit: jest.fn(),
    13	  })),
    14	}));
    15	
    16	// Mock webhook normalizer before any imports
    17	jest.mock('@neuronx/adapters/webhooks', () => ({
    18	  WebhookNormalizer: jest.fn().mockImplementation(() => ({
    19	    processWebhook: jest.fn(),
    20	  })),
    21	}));
    22	
    23	// Mock controllers before importing them
    24	jest.mock('../../integrations/ghl/ghl-webhook.controller', () => ({
    25	  GhlWebhookController: jest.fn().mockImplementation(() => ({
    26	    handleWebhook: jest.fn(),
    27	  })),
    28	}));
    29	
    30	jest.mock('../../payments/webhooks/payment-webhook.controller', () => ({
    31	  PaymentWebhookController: jest.fn().mockImplementation(() => ({
    32	    handleWebhook: jest.fn(),
    33	  })),
    34	}));
    35	
    36	/**
    37	 * Webhook Security Ordering Tests - REQ-RATE: Correct Webhook Flow
    38	 *
    39	 * Tests that webhook controllers follow the correct security ordering:
    40	 * 1. Signature verification (cheap reject if invalid)
    41	 * 2. Rate limiting (tenant/provider scoped)
    42	 * 3. Business processing
    43	 *
    44	 * Ensures unauthenticated spam cannot drain tenant webhook quotas.
    45	 */
    46	
    47	import { Test, TestingModule } from '@nestjs/testing';
    48	import { GhlWebhookController } from '../../integrations/ghl/ghl-webhook.controller';
    49	import { PaymentWebhookController } from '../../payments/webhooks/payment-webhook.controller';
    50	import { PaymentService } from '../../payments/payment.service';
    51	import { RateLimitService } from '../rate-limit.service';
    52	import { WebhookNormalizer } from '@neuronx/adapters/webhooks';
    53	import { UnauthorizedException, BadRequestException } from '@nestjs/common';
    54	
    55	describe('Webhook Security Ordering - Signature Before Rate Limit', () => {
    56	  let ghlController: GhlWebhookController;
    57	  let paymentController: PaymentWebhookController;
    58	  let mockRateLimitService: any;
    59	  let mockWebhookNormalizer: any;
    60	
    61	  // Mock the webhook normalizer
    62	  const mockWebhookNormalizerResult = {
    63	    processed: true,
    64	    event: {
    65	      type: 'contact.created',
    66	      metadata: { correlationId: 'test-correlation-id' },
    67	    },
    68	    verification: { valid: true },
    69	  };
    70	
    71	  beforeEach(async () => {
    72	    mockRateLimitService = {
    73	      enforceWebhookRateLimit: jest.fn(),
    74	    };
    75	
    76	    mockWebhookNormalizer = {
    77	      processWebhook: jest.fn(),
    78	    };
    79	
    80	    // Setup GHL controller
    81	    const ghlModule: TestingModule = await Test.createTestingModule({
    82	      controllers: [GhlWebhookController],
    83	      providers: [
    84	        {
    85	          provide: WebhookNormalizer,
    86	          useValue: mockWebhookNormalizer,
    87	        },
    88	        {
    89	          provide: RateLimitService,
    90	          useValue: mockRateLimitService,
    91	        },
    92	      ],
    93	    }).compile();
    94	
    95	    ghlController = ghlModule.get<GhlWebhookController>(GhlWebhookController);
    96	
    97	    // Setup Payment controller
    98	    const paymentModule: TestingModule = await Test.createTestingModule({
    99	      controllers: [PaymentWebhookController],
   100	      providers: [
   101	        {
   102	          provide: RateLimitService,
   103	          useValue: mockRateLimitService,
   104	        },
   105	        {
   106	          provide: 'PAYMENT_SERVICE',
   107	          useValue: { verifyPaymentFromWebhook: jest.fn() },
   108	        },
   109	        {
   110	          provide: PaymentService,
   111	          useValue: { verifyPaymentFromWebhook: jest.fn() },
   112	        },
   113	      ],
   114	    }).compile();
   115	
   116	    paymentController = paymentModule.get<PaymentWebhookController>(PaymentWebhookController);
   117	  });
   118	
   119	  afterEach(() => {
   120	    jest.clearAllMocks();
   121	  });
   122	
   123	  describe('GHL Webhook Controller Ordering', () => {
   124	    const validHeaders = {
   125	      'x-tenant-id': 'test-tenant',
   126	      'x-webhook-signature': 'valid-signature',
   127	      'x-request-id': 'test-request-id',
   128	    };
   129	
   130	    const mockRequest = {
   131	      url: '/integrations/ghl/webhooks',
   132	      method: 'POST',
   133	      headers: validHeaders,
   134	    };
   135	
   136	    it('should reject invalid signature before rate limiting is called', async () => {
   137	      const invalidSignatureHeaders = { ...validHeaders, 'x-webhook-signature': '' };
   138	
   139	      mockWebhookNormalizer.processWebhook.mockResolvedValueOnce({
   140	        processed: false,
   141	        verification: { valid: false },
   142	      });
   143	
   144	      await expect(
   145	        ghlController.processWebhook(
   146	          { event: 'contact.created' },
   147	          invalidSignatureHeaders,
   148	          mockRequest as any
   149	        )
   150	      ).rejects.toThrow(UnauthorizedException);
   151	
   152	      // Rate limit service should NOT be called for invalid signatures
   153	      expect(mockRateLimitService.enforceWebhookRateLimit).not.toHaveBeenCalled();
   154	    });
   155	
   156	    it('should call rate limiting after valid signature verification', async () => {
   157	      // Mock successful signature verification
   158	      mockWebhookNormalizer.processWebhook.mockResolvedValueOnce(mockWebhookNormalizerResult);
   159	
   160	      // Mock successful rate limiting
   161	      mockRateLimitService.enforceWebhookRateLimit.mockResolvedValueOnce(undefined);
   162	
   163	      const result = await ghlController.processWebhook(
   164	        { event: 'contact.created' },
   165	        validHeaders,
   166	        mockRequest as any
   167	      );
   168	
   169	      // Rate limit service should be called AFTER signature verification
   170	      expect(mockRateLimitService.enforceWebhookRateLimit).toHaveBeenCalledWith({
   171	        req: mockRequest,
   172	        providerId: 'ghl',
   173	      });
   174	
   175	      // Should process successfully
   176	      expect(result).toEqual(
   177	        expect.objectContaining({ status: 'processed' })
   178	      );
   179	    });
   180	
   181	    it('should reject rate limited requests after valid signature', async () => {
   182	      // Mock successful signature verification
   183	      mockWebhookNormalizer.processWebhook.mockResolvedValueOnce(mockWebhookNormalizerResult);
   184	
   185	      // Mock rate limit exceeded
   186	      const rateLimitError = new Error('Rate limit exceeded');
   187	      (rateLimitError as any).response = { retryAfter: 60 };
   188	      mockRateLimitService.enforceWebhookRateLimit.mockRejectedValueOnce(rateLimitError);
   189	
   190	      await expect(
   191	        ghlController.processWebhook(
   192	          { event: 'contact.created' },
   193	          validHeaders,
   194	          mockRequest as any
   195	        )
   196	      ).rejects.toThrow('Rate limit exceeded');
   197	
   198	      // Verify rate limit was checked
   199	      expect(mockRateLimitService.enforceWebhookRateLimit).toHaveBeenCalledWith({
   200	        req: mockRequest,
   201	        providerId: 'ghl',
   202	      });
   203	    });
   204	
   205	    it('should process business logic only after signature + rate limit pass', async () => {
   206	      // Mock successful signature verification
   207	      mockWebhookNormalizer.processWebhook.mockResolvedValueOnce(mockWebhookNormalizerResult);
   208	
   209	      // Mock successful rate limiting
   210	      mockRateLimitService.enforceWebhookRateLimit.mockResolvedValueOnce(undefined);
   211	
   212	      const result = await ghlController.processWebhook(
   213	        { event: 'contact.created' },
   214	        validHeaders,
   215	        mockRequest as any
   216	      );
   217	
   218	      // Verify the correct order:
   219	      // 1. processWebhook called first (signature verification)
   220	      expect(mockWebhookNormalizer.processWebhook).toHaveBeenCalledTimes(1);
   221	
   222	      // 2. enforceWebhookRateLimit called second (rate limiting)
   223	      expect(mockRateLimitService.enforceWebhookRateLimit).toHaveBeenCalledTimes(1);
   224	
   225	      // 3. Response indicates successful processing
   226	      expect(result).toEqual(
   227	        expect.objectContaining({ status: 'processed' })
   228	      );
   229	    });
   230	  });
   231	
   232	  describe('Payment Webhook Controller Ordering', () => {
   233	    const validHeaders = {
   234	      'x-tenant-id': 'payment-tenant',
   235	      'stripe-signature': 'valid-stripe-signature',
   236	    };
   237	
   238	    const mockRequest = {
   239	      url: '/payments/webhooks/stripe',
   240	      method: 'POST',
