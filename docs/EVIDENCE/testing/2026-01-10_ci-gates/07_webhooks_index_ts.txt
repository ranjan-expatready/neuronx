     1	// Webhook Normalization Layer - Production Hardened
     2	// Converts vendor-specific webhooks into canonical NeuronX domain events
     3	
     4	import { EventBus } from '@neuronx/eventing';
     5	import { GhlWebhookPayload } from '../ghl/ghl.types';
     6	import { createHmac } from 'crypto';
     7	
     8	export interface WebhookEvent {
     9	  type: string;
    10	  tenantId: string;
    11	  data: any;
    12	  metadata: {
    13	    correlationId: string;
    14	    timestamp: Date;
    15	    source: 'webhook';
    16	    vendor: string;
    17	    webhookId?: string; // For deduplication
    18	  };
    19	}
    20	
    21	export interface WebhookVerificationResult {
    22	  valid: boolean;
    23	  error?: string;
    24	  algorithm?: string;
    25	}
    26	
    27	export interface ReplayCheckResult {
    28	  isDuplicate: boolean;
    29	  processedAt?: Date;
    30	}
    31	
    32	export interface WebhookHandler {
    33	  canHandle(payload: any): boolean;
    34	  normalize(payload: any, tenantId: string, webhookId?: string): WebhookEvent | null;
    35	}
    36	
    37	export class WebhookSignatureVerifier {
    38	  constructor(private webhookSecret?: string) {}
    39	
    40	  /**
    41	   * Verify webhook signature using HMAC-SHA256
    42	   */
    43	  verifySignature(
    44	    payload: any,
    45	    signature: string,
    46	    algorithm: string = 'sha256'
    47	  ): WebhookVerificationResult {
    48	    if (!this.webhookSecret) {
    49	      // In development, allow skipping verification with explicit warning
    50	      console.warn('WEBHOOK VERIFICATION DISABLED: No webhook secret configured');
    51	      return { valid: true, algorithm: 'none' };
    52	    }
    53	
    54	    if (!signature) {
    55	      return { valid: false, error: 'Missing signature' };
    56	    }
    57	
    58	    try {
    59	      // Extract algorithm and signature from header (e.g., "sha256=abc123")
    60	      const [sigAlgorithm, sigValue] = signature.split('=');
    61	
    62	      if (!sigAlgorithm || !sigValue) {
    63	        return { valid: false, error: 'Invalid signature format' };
    64	      }
    65	
    66	      if (sigAlgorithm !== algorithm) {
    67	        return { valid: false, error: `Unsupported algorithm: ${sigAlgorithm}` };
    68	      }
    69	
    70	      // Create expected signature
    71	      const payloadString = typeof payload === 'string' ? payload : JSON.stringify(payload);
    72	      const expectedSignature = createHmac(algorithm, this.webhookSecret)
    73	        .update(payloadString, 'utf8')
    74	        .digest('hex');
    75	
    76	      // Compare signatures (constant-time comparison)
    77	      const valid = this.constantTimeCompare(sigValue, expectedSignature);
    78	
    79	      return {
    80	        valid,
    81	        algorithm: sigAlgorithm,
    82	        error: valid ? undefined : 'Signature mismatch'
    83	      };
    84	
    85	    } catch (error) {
    86	      return {
    87	        valid: false,
    88	        error: `Verification error: ${error.message}`
    89	      };
    90	    }
    91	  }
    92	
    93	  /**
    94	   * Constant-time string comparison to prevent timing attacks
    95	   */
    96	  private constantTimeCompare(a: string, b: string): boolean {
    97	    if (a.length !== b.length) {
    98	      return false;
    99	    }
   100	
   101	    let result = 0;
   102	    for (let i = 0; i < a.length; i++) {
   103	      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
   104	    }
   105	
   106	    return result === 0;
   107	  }
   108	}
   109	
   110	export class WebhookReplayProtector {
   111	  private processedWebhooks = new Map<string, Date>();
   112	  private readonly retentionPeriod = 24 * 60 * 60 * 1000; // 24 hours
   113	
   114	  /**
   115	   * Check if webhook has been processed recently
   116	   */
   117	  checkReplay(webhookId: string, timestamp: Date): ReplayCheckResult {
   118	    // Clean up old entries
   119	    this.cleanup();
   120	
   121	    const key = this.generateKey(webhookId, timestamp);
   122	    const processedAt = this.processedWebhooks.get(key);
   123	
   124	    if (processedAt) {
   125	      return { isDuplicate: true, processedAt };
   126	    }
   127	
   128	    // Mark as processed
   129	    this.processedWebhooks.set(key, new Date());
   130	    return { isDuplicate: false };
   131	  }
   132	
   133	  /**
   134	   * Generate unique key for webhook deduplication
   135	   */
   136	  private generateKey(webhookId: string, timestamp: Date): string {
   137	    // Include timestamp rounded to minute to catch near-duplicate events
   138	    const minuteTimestamp = Math.floor(timestamp.getTime() / 60000) * 60000;
   139	    return `${webhookId}:${minuteTimestamp}`;
   140	  }
   141	
   142	  /**
   143	   * Clean up old processed webhook records
   144	   */
   145	  private cleanup(): void {
   146	    const cutoff = Date.now() - this.retentionPeriod;
   147	
   148	    for (const [key, processedAt] of this.processedWebhooks.entries()) {
   149	      if (processedAt.getTime() < cutoff) {
   150	        this.processedWebhooks.delete(key);
   151	      }
   152	    }
   153	  }
   154	
   155	  /**
   156	   * Get statistics for monitoring
   157	   */
   158	  getStats(): { processedCount: number; retentionPeriod: number } {
   159	    return {
   160	      processedCount: this.processedWebhooks.size,
   161	      retentionPeriod: this.retentionPeriod,
   162	    };
   163	  }
   164	}
   165	
   166	export class GhlWebhookHandler implements WebhookHandler {
   167	  canHandle(payload: any): boolean {
   168	    return payload.event && typeof payload.event === 'string' && payload.locationId;
   169	  }
   170	
   171	  normalize(payload: GhlWebhookPayload, tenantId: string, webhookId?: string): WebhookEvent | null {
   172	    const correlationId = `webhook_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
   173	
   174	    switch (payload.event) {
   175	      case 'contact.created':
   176	        return {
   177	          type: 'neuronx.contact.ingested',
   178	          tenantId,
   179	          data: {
   180	            externalId: payload.data.id,
   181	            email: payload.data.email,
   182	            phone: payload.data.phone,
   183	            firstName: payload.data.firstName,
   184	            lastName: payload.data.lastName,
   185	            source: 'ghl_webhook',
   186	            locationId: payload.locationId,
   187	          },
   188	          metadata: {
   189	            correlationId,
   190	            timestamp: new Date(),
   191	            source: 'webhook',
   192	            vendor: 'ghl',
   193	            webhookId,
   194	          },
   195	        };
   196	
   197	      case 'contact.updated':
   198	        return {
   199	          type: 'neuronx.contact.updated',
   200	          tenantId,
